emqx_schema {

  force_shutdown_enable {
    desc {
      en: "Enable `force_shutdown` feature."
      zh: "启用 `force_shutdown` 功能"
    }
    label {
      en: "Enable `force_shutdown` feature."
      zh: "启用 `force_shutdown` 功能"
    }
  }

  force_shutdown_max_message_queue_len {
    desc {
      en: "Maximum message queue length."
      zh: "消息队列的最大长度"
    }
    label {
      en: "Maximum mailbox queue length of process."
      zh: "进程邮箱消息队列的最大长度"
    }
  }

  force_shutdown_max_heap_size {
    desc {
        en: "Total heap size"
        zh: "Heap 的总大小"
    }
    label {
        en: "Total heap size"
        zh: "Heap 的总大小"
    }
  }

  overload_protection_enable {
    desc {
        en: "React on system overload or not"
        zh: "是否对系统过载做出反应"
    }
    label {
        en: "React on system overload or not"
        zh: "是否对系统过载做出反应"
    }
  }

  overload_protection_backoff_delay {
    desc {
        en: "Some unimportant tasks could be delayed "
            "for execution, here set the delays in ms"
        zh: "一些不重要的任务可能会延迟执行，以毫秒为单位设置延迟"
    }
    label {
        en: "Delay Time"
        zh: "延迟时间"
    }
  }

  overload_protection_backoff_gc {
    desc {
        en: "Skip forceful GC if necessary"
        zh: "如有必要，跳过强制GC"
    }
    label {
        en: "Skip GC"
        zh: "跳过GC"
    }
  }

  overload_protection_backoff_hibernation {
    desc {
        en: "Skip process hibernation if necessary"
        zh: "如有必要，跳过进程休眠"
    }
    label {
        en: "Skip hibernation"
        zh: "跳过休眠"
    }
  }

  overload_protection_backoff_new_conn {
    desc {
        en: "Close new incoming connections if necessary"
        zh: "如有必要，关闭新进来的连接"
    }
    label {
        en: "Close new connections"
        zh: "关闭新连接"
    }
  }

  conn_congestion_enable_alarm {
    desc {
        en: "Enable or disable connection congestion alarm."
        zh: "启用或者禁用连接阻塞告警功能"
    }
    label {
        en: "Enable/disable congestion alarm"
        zh: "启用/禁用阻塞告警"
    }
  }

  conn_congestion_min_alarm_sustain_duration {
    desc {
        en: "Minimal time before clearing the alarm.\n\n"
            "The alarm is cleared only when there's no pending data in\n"
            "the queue, and at least `min_alarm_sustain_duration`\n"
            "milliseconds passed since the last time we considered the connection \"congested\".\n\n"
            "This is to avoid clearing and raising the alarm again too often."
        zh: "清除警报前的最短时间。\n\n"
            "只有当队列中没有挂起的数据，并且连接至少被堵塞了 \"min_alarm_sustain_duration\" 毫秒时，\n"
            "报警才会被清除。这是为了避免太频繁地清除和再次发出警报."
    }
    label {
        en: "Sustain duration"
        zh: "告警维持时间"
    }
  }

  force_gc_enable {
    desc {
        en: "Enable forced garbage collection."
        zh: "启用强制垃圾回收"
    }
    label {
        en: "Enable forced garbage collection."
        zh: "启用强制垃圾回收"
    }
  }

  force_gc_count {
    desc {
        en: "GC the process after this many received messages."
        zh: "在进程收到多少消息之后，对此进程执行垃圾回收"
    }
    label {
        en: "Process GC messages num"
        zh: "垃圾回收消息数"
    }
  }

  force_gc_bytes {
    desc {
        en: "GC the process after specified number of bytes have passed through."
        zh: "在进程处理过多少个字节之后，对此进程执行垃圾回收"
    }
    label {
        en: "Process GC bytes"
        zh: "垃圾回收字节数"
    }
  }

  sysmon_vm_process_check_interval {
    desc {
        en: "The time interval for the periodic process limit check."
        zh: "定期进程限制检查的时间间隔。"
    }
    label {
        en: "Process limit check interval"
        zh: "进程限制检查时间"
    }
  }

  sysmon_vm_process_high_watermark {
    desc {
        en: "The threshold, as percentage of processes, for how many\n"
            " processes can simultaneously exist at the local node before the corresponding\n"
            " alarm is raised."
        zh: "在发出相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。"
    }
    label {
        en: "Process high watermark"
        zh: "进程数高水位线"
    }
  }

  sysmon_vm_process_low_watermark {
    desc {
        en: "The threshold, as percentage of processes, for how many\n"
            " processes can simultaneously exist at the local node before the corresponding\n"
            " alarm is cleared."
        zh: "在清除相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。"
    }
    label {
        en: "Process low watermark"
        zh: "进程数低水位线"
    }
  }

  sysmon_vm_long_gc {
    desc {
        en: "Enable Long GC monitoring."
        zh: "启用长垃圾回收监控"
    }
    label {
        en: "Enable Long GC monitoring."
        zh: "启用长垃圾回收监控"
    }
  }

  sysmon_vm_long_schedule {
    desc {
        en: "Enable Long Schedule monitoring."
        zh: "启用长调度监控"
    }
    label {
        en: "Enable Long Schedule monitoring."
        zh: "启用长调度监控"
    }
  }

  sysmon_vm_large_heap {
    desc {
        en: "Enable Large Heap monitoring."
        zh: "启用大 heap 监控"
    }
    label {
        en: "Enable Large Heap monitoring."
        zh: "启用大 heap 监控"
    }
  }

  sysmon_vm_busy_dist_port {
    desc {
        en: "Enable Busy Distribution Port monitoring."
        zh: "启用分布式端口过忙监控"
    }
    label {
        en: "Enable Busy Distribution Port monitoring."
        zh: "启用分布式端口过忙监控"
    }
  }

  sysmon_vm_busy_port {
    desc {
        en: "Enable Busy Port monitoring."
        zh: "启用端口过忙监控"
    }
    label {
        en: "Enable Busy Port monitoring."
        zh: "启用端口过忙监控"
    }
  }

  sysmon_os_cpu_check_interval {
    desc {
        en: "The time interval for the periodic CPU check."
        zh: "定期 CPU 检查的时间间隔。"
    }
    label {
        en: "The time interval for the periodic CPU check."
        zh: "定期 CPU 检查的时间间隔"
    }
  }

  sysmon_os_cpu_high_watermark {
    desc {
        en: "The threshold, as percentage of system CPU load,\n"
            " for how much system cpu can be used before the corresponding alarm is raised."
        zh: "在发出相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。"
    }
    label {
        en: "CPU high watermark"
        zh: "CPU 高水位线"
    }
  }

  sysmon_os_cpu_low_watermark {
    desc {
        en: "The threshold, as percentage of system CPU load,\n"
            " for how much system cpu can be used before the corresponding alarm is cleared."
        zh: "在解除相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。"
    }
    label {
        en: "CPU low watermark"
        zh: "CPU 低水位线"
    }
  }

  sysmon_os_mem_check_interval {
    desc {
        en: "The time interval for the periodic memory check."
        zh: "定期内存检查的时间间隔。"
    }
    label {
        en: "Mem check interval"
        zh: "内存检查间隔"
    }
  }

  sysmon_os_sysmem_high_watermark {
    desc {
        en: "The threshold, as percentage of system memory,\n"
            " for how much system memory can be allocated before the corresponding alarm is raised."
        zh: "在发出相应报警之前可以分配多少系统内存的阈值，以系统内存的百分比表示。"
    }
    label {
        en: "SysMem high wartermark"
        zh: "系统内存高水位线"
    }
  }

  sysmon_os_procmem_high_watermark {
    desc {
        en: "The threshold, as percentage of system memory,\n"
        " for how much system memory can be allocated by one Erlang process before\n"
        " the corresponding alarm is raised."
        zh: "在发出相应警报之前，一个Erlang进程可以分配多少系统内存的阈值，以系统内存的百分比表示。"
    }
    label {
        en: "ProcMem high wartermark"
        zh: "进程内存高水位线"
    }
  }

  sysmon_top_num_items {
    desc {
        en: "The number of top processes per monitoring group"
        zh: "每个监视组的顶级进程数"
    }
    label {
        en: "Top num items"
        zh: "顶级进程数"
    }
  }

  sysmon_top_sample_interval {
    desc {
        en: "Specifies how often process top should be collected"
        zh: "指定应收集进程顶部的频率"
    }
    label {
        en: "Top sample interval"
        zh: "取样时间"
    }
  }

  sysmon_top_max_procs {
    desc {
        en: "Stop collecting data when the number of processes\n"
            "in the VM exceeds this value"
        zh: "当VM中的进程数超过此值时，停止收集数据"
    }
    label {
        en: "Max procs"
        zh: "最大进程数"
    }
  }

  sysmon_top_db_hostname {
    desc {
        en: "Hostname of the PostgreSQL database that collects the data points"
        zh: "收集数据点的 PostgreSQL 数据库的主机名"
    }
    label {
        en: "DB Hostname"
        zh: "数据库主机名"
    }
  }

  sysmon_top_db_port {
    desc {
        en: "Port of the PostgreSQL database that collects the data points"
        zh: "收集数据点的 PostgreSQL 数据库的端口"
    }
    label {
        en: "DB Port"
        zh: "数据库端口"
    }
  }

  sysmon_top_db_username {
    desc {
        en: "Username of the PostgreSQL database"
        zh: "PostgreSQL 数据库的用户名"
    }
    label {
        en: "DB Username"
        zh: "数据库用户名"
    }
  }

  sysmon_top_db_password {
    desc {
        en: "EMQX user password in the PostgreSQL database"
        zh: "PostgreSQL 数据库的密码"
    }
    label {
        en: "DB Password"
        zh: "数据库密码"
    }
  }

  sysmon_top_db_name {
    desc {
        en: "PostgreSQL database name"
        zh: "PostgreSQL 数据库的数据库名"
    }
    label {
        en: "DB Name"
        zh: "数据库名"
    }
  }

  alarm_actions {
    desc {
        en: "The actions triggered when the alarm is activated.</br>\n"
            "Currently, the following actions are supported: <code>log</code> and "
            "<code>publish</code>.\n"
            "<code>log</code> is to write the alarm to log (console or file).\n"
            "<code>publish</code> is to publish the alarm as an MQTT message to "
            "the system topics:\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"
        zh: "警报激活时触发的动作。</br>\n"
            "目前，支持以下操作：<code>log</code> 和 "
            "<code>publish</code>.\n"
            "<code>log</code> 将告警写入日志 (控制台或者文件).\n"
            "<code>publish</code> 将告警作为 MQTT 消息发布到系统主题:\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"
    }
    label: {
        en: "Alarm Actions"
        zh: "告警动作"
    }
  }

  alarm_size_limit {
    desc {
        en: "The maximum total number of deactivated alarms to keep as history.</br>\n"
            "When this limit is exceeded, the oldest deactivated alarms are "
            "deleted to cap the total number.\n"
        zh: "要保留为历史记录的已停用报警的最大总数。当超过此限制时，将删除最旧的停用报警，以限制总数。"
    }
    label: {
        en: "Alarm size limit"
        zh: "告警总数限制"
    }
  }

  alarm_validity_period {
    desc {
        en: "Retention time of deactivated alarms. Alarms are not deleted immediately\n"
            "when deactivated, but after the retention time.\n"
        zh: "停用报警的保留时间。报警在停用时不会立即删除，而是在保留时间之后删除。"
    }
    label: {
        en: "Alarm validity period"
        zh: "告警保留时间"
    }
  }

  flapping_detect_enable {
    desc {
        en: "Enable flapping connection detection feature."
        zh: "启用抖动检测功能"
    }
    label: {
        en: "Enable flapping detection"
        zh: "启用抖动检测"
    }
  }

  flapping_detect_max_count {
    desc {
        en: "The maximum number of disconnects allowed for a MQTT Client in `window_time`"
        zh: "MQTT 客户端在\"窗口\"时间内允许的最大断开次数"
    }
    label: {
        en: "Max count"
        zh: "最大断开次数"
    }
  }

  flapping_detect_window_time {
    desc {
        en: "The time window for flapping detection."
        zh: "抖动检测的时间窗口。"
    }
    label: {
        en: "Window time"
        zh: "时间窗口"
    }
  }

  flapping_detect_ban_time {
    desc {
        en: "How long the flapping clientid will be banned."
        zh: "抖动的客户端将会被禁止登陆多长时间"
    }
    label: {
        en: "Ban time"
        zh: "禁止登陆时长"
    }
  }

  persistent_session_store_enabled {
    desc {
        en: "Use the database to store information about persistent sessions.\n"
            "This makes it possible to migrate a client connection to another\n"
            "cluster node if a node is stopped.\n"
        zh: "使用数据库存储有关持久会话的信息。\n"
            "这使得在节点停止时，可以将客户端连接迁移到另一个群集节点。"
    }
    label: {
        en: "Enable persistent session store"
        zh: "启用持久会话保存"
    }
  }

  persistent_session_store_backend {
    desc {
        en: "Database management system used to store information about persistent sessions and messages.\n"
            "- `builtin`: Use the embedded database (mria)"
        zh: "用于存储持久性会话和信息的数据库管理后端\n"
            "- `builtin`: 使用内置的数据库（mria）"
    }
    label: {
        en: "Backend"
        zh: "后端类型"
    }
  }

  persistent_store_on_disc {
    desc {
        en: "Save information about the persistent sessions on disc.\n"
            "If this option is enabled, persistent sessions will survive full restart of the cluster.\n"
            "Otherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped."
        zh: "将持久会话数据保存在磁盘上。如果为 false 则存储在内存中。\n"
            "如开启， 持久会话数据可在集群重启后恢复。\n"
            "如关闭， 数据仅存储在内存中， 则在整个集群停止后丢失。"
    }
    label: {
        en: "Persist on disc"
        zh: "持久化在磁盘上"
    }
  }

  persistent_store_ram_cache {
    desc {
        en: "Maintain a copy of the data in RAM for faster access."
        zh: "在内存中保持一份数据的副本，以便更快地访问。"
    }
    label: {
        en: "RAM cache"
        zh: "内存缓存"
    }
  }

  persistent_session_store_max_retain_undelivered {
    desc {
        en: "The time messages that was not delivered to a persistent session\n"
            "is stored before being garbage collected if the node the previous\n"
            "session was handled on restarts of is stopped.\n"
        zh: "如果重新启动时处理上一个会话的节点已停止，则未传递到持久会话的消息在垃圾收集之前会被存储。"
    }
    label: {
        en: "Max retain undelivered"
        zh: "未投递的消息保留条数"
    }
  }

  persistent_session_store_message_gc_interval {
    desc {
        en: "The starting interval for garbage collection of undelivered messages to\n"
            "a persistent session. This affects how often the \"max_retain_undelivered\"\n"
            "is checked for removal.\n"
        zh: "将未送达的消息垃圾收集到持久会话的开始间隔。\n"
            "这会影响检查 \"max_retain_undelivered\"（最大保留未送达）的删除频率。"
    }
    label: {
        en: "Message GC interval"
        zh: "消息清理间隔"
    }
  }

  persistent_session_store_session_message_gc_interval {
    desc {
        en: "The starting interval for garbage collection of transient data for\n"
            "persistent session messages. This does not affect the lifetime length\n"
            "of persistent session messages.\n"
        zh: "持久会话消息的临时数据垃圾收集的开始间隔。\n"
            "这不会影响持久会话消息的生命周期长度。\n"
    }
    label: {
        en: "Session message GC interval"
        zh: "会话消息清理间隔"
    }
  }

  persistent_session_builtin_session_table {
    desc {
         en: "Performance tuning options for built-in session table."
         zh: "用于内建会话表的性能调优参数"
    }
    label: {
         en: "Persistent session"
         zh: "持久会话"
    }
  }

  persistent_session_builtin_sess_msg_table {
    desc {
         en: "Performance tuning options for built-in session messages table."
         zh: "优化内置的会话消息表的配置。"
    }
    label: {
         en: "Persistent session messages"
         zh: "用于内建会话管理表的性能调优参数"
    }
  }

  persistent_session_builtin_messages_table {
    desc {
         en: "Performance tuning options for built-in messages table."
         zh: "用于内建消息表的性能调优参数"
    }
    label: {
         en: "Persistent messages"
         zh: "持久化消息"
    }
  }

  stats_enable {
    desc {
        en: "Enable/disable statistic data collection."
        zh: "启用/禁用统计数据收集功能"
    }
    label: {
        en: "Enable/disable statistic data collection."
        zh: "启用/禁用统计数据收集功能"
    }
  }

    zones {
        desc {
            en: """A zone is a set of configs grouped by the zone <code>name</code>.
For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.
NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.
"""
            zh: """<code>zone</code> 是按<code>name</code> 分组的一组配置。
对于灵活的配置映射，可以将 <code>name</code> 设置为侦听器的 <code>zone</code> 配置。
注：名为 <code>default</code> 的内置区域是自动创建的，无法删除。"""
        }
    }

    mqtt {
        desc {
            en: """Global MQTT configuration.
The configs here work as default values which can be overridden in <code>zone</code> configs
"""
            zh: """全局的 MQTT 配置项。
mqtt 下所有的配置作为全局的默认值存在，它可以被 <code>zone</code> 中的配置覆盖。"""
        }
    }

    mqtt_idle_timeout {
        desc {
            en: """After the TCP connection is established, if the MQTT CONNECT packet from the client is not received within the time specified by <code>idle_timeout</code>, the connection will be disconnected."""
            zh: """TCP 连接建立后，如果在 <code>idle_timeout</code> 指定的时间内未收到客户端的 MQTT CONNECT 报文，则连接将被断开。"""
        }
        label: {
            en: """Idle Timeout"""
            zh: """空闲超时"""
        }
    }

    mqtt_max_packet_size {
        desc {
            en: """Maximum MQTT packet size allowed."""
            zh: """允许的最大 MQTT 报文大小。"""
        }
        label: {
            en: """Max Packet Size"""
            zh: """最大报文大小"""
        }
    }

    mqtt_max_clientid_len {
        desc {
            en: """Maximum allowed length of MQTT Client ID."""
            zh: """允许的最大 MQTT Client ID 长度。"""
        }
        label: {
            en: """Max Client ID Length"""
            zh: """最大 Client ID 长度"""
        }
    }

    mqtt_max_topic_levels {
        desc {
            en: """Maximum topic levels allowed."""
            zh: """允许的最大主题层级。"""
        }
        label: {
            en: """Max Topic Levels"""
            zh: """最大主题层级"""
        }
    }

    mqtt_max_qos_allowed {
        desc {
            en: """Maximum QoS allowed."""
            zh: """允许的最大 QoS 等级。"""
        }
        label: {
            en: """Max QoS"""
            zh: """最大 QoS"""
        }
    }

    mqtt_max_topic_alias {
        desc {
            en: """Maximum topic alias, 0 means no topic alias supported."""
            zh: """允许的最大主题别名数，0 表示不支持主题别名。"""
        }
        label: {
            en: """Max Topic Alias"""
            zh: """最大主题别名"""
        }
    }

    mqtt_retain_available {
        desc {
            en: """Whether to enable support for MQTT retained message."""
            zh: """是否启用对 MQTT 保留消息的支持。"""
        }
        label: {
            en: """Retain Available"""
            zh: """保留消息可用"""
        }
    }

    mqtt_wildcard_subscription {
        desc {
            en: """Whether to enable support for MQTT wildcard subscription."""
            zh: """是否启用对 MQTT 通配符订阅的支持。"""
        }
        label: {
            en: """Wildcard Subscription Available"""
            zh: """通配符订阅可用"""
        }
    }

    mqtt_shared_subscription {
        desc {
            en: """Whether to enable support for MQTT shared subscription."""
            zh: """是否启用对 MQTT 共享订阅的支持。"""
        }
        label: {
            en: """Shared Subscription Available"""
            zh: """共享订阅可用"""
        }
    }

    mqtt_exclusive_subscription {
        desc {
            en: """Whether to enable support for MQTT exclusive subscription."""
            zh: """是否启用对 MQTT 排它订阅的支持。"""
        }
        label: {
            en: """Exclusive Subscription"""
            zh: """排它订阅"""
        }
    }

    mqtt_ignore_loop_deliver {
        desc {
            en: """Ignore loop delivery of messages for MQTT v3.1.1/v3.1.0, similar to <code>No Local</code> subscription option in MQTT 5.0"""
            zh: """是否为 MQTT v3.1.1/v3.1.0 客户端忽略投递自己发布的消息，类似于 MQTT 5.0 中的 <code>No Local</code> 订阅选项"""
        }
        label: {
            en: """Ignore Loop Deliver"""
            zh: """忽略循环投递"""
        }
    }

    mqtt_strict_mode {
        desc {
            en: """Parse MQTT messages in strict mode.
When set to true, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected"""
            zh: """是否以严格模式解析 MQTT 消息。
当设置为 true 时，例如客户端 ID、主题名称等中的无效 utf8 字符串将导致客户端断开连接。"""
        }
        label: {
            en: """Strict Mode"""
            zh: """严格模式"""
        }
    }

    mqtt_response_information {
        desc {
            en: """Specify the response information returned to the client. This feature is disabled if is set to \"\". Applies only to clients using MQTT 5.0."""
            zh: """指定返回给客户端的响应信息。如果设置为 \"\"，则禁用此功能。仅适用于使用 MQTT 5.0 协议的客户端。"""
        }
        label: {
            en: """Response Information"""
            zh: """响应信息"""
        }
    }

    mqtt_server_keepalive {
        desc {
            en: """The keep alive that EMQX requires the client to use. If configured as <code>disabled</code>, it means that the keep alive specified by the client will be used. Requires <code>Server Keep Alive</code> in MQTT 5.0, so it is only applicable to clients using MQTT 5.0 protocol."""
            zh: """EMQX 要求客户端使用的保活时间，配置为 <code>disabled</code> 表示将使用客户端指定的保活时间。需要用到 MQTT 5.0 中的 <code>Server Keep Alive</code>，因此仅适用于使用 MQTT 5.0 协议的客户端。"""
        }
        label: {
            en: """Server Keep Alive"""
            zh: """服务端保持连接"""
        }
    }

    mqtt_keepalive_backoff {
        desc {
            en: """The backoff multiplier used by the broker to determine the client keep alive timeout. If EMQX doesn't receive any packet in <code>Keep Alive * Backoff * 2</code> seconds, EMQX will close the current connection."""
            zh: """Broker 判定客户端保活超时使用的退避乘数。如果 EMQX 在 <code>Keep Alive * Backoff * 2</code> 秒内未收到任何报文，EMQX 将关闭当前连接。"""
        }
        label: {
            en: """Keep Alive Backoff"""
            zh: """保持连接退避乘数"""
        }
    }

    mqtt_max_subscriptions {
        desc {
            en: """Maximum number of subscriptions allowed per client."""
            zh: """允许每个客户端建立的最大订阅数量。"""
        }
        label: {
            en: """Max Subscriptions"""
            zh: """最大订阅数量"""
        }
    }

    mqtt_upgrade_qos {
        desc {
            en: """Force upgrade of QoS level according to subscription."""
            zh: """投递消息时，是否根据订阅主题时的 QoS 等级来强制提升派发的消息的 QoS 等级。"""
        }
        label: {
            en: """Upgrade QoS"""
            zh: """升级 QoS"""
        }
    }

    mqtt_max_inflight {
        desc {
            en: """Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment."""
            zh: """允许在完成应答前同时投递的 QoS 1 和 QoS 2 消息的最大数量。"""
        }
        label: {
            en: """Max Inflight"""
            zh: """最大飞行窗口"""
        }

    }

    mqtt_retry_interval {
        desc {
            en: """Retry interval for QoS 1/2 message delivering."""
            zh: """QoS 1/2 消息的重新投递间隔。"""
        }
        label: {
            en: """Retry Interval"""
            zh: """重试间隔"""
        }
    }

    mqtt_max_awaiting_rel {
        desc {
            en: """Maximum QoS 2 packets (Client -> Broker) awaiting PUBREL."""
            zh: """PUBREL (Client -> Broker) 最大等待队列长度。"""
        }
        label: {
            en: """Max Awaiting PUBREL"""
            zh: """Max Awaiting PUBREL"""
        }
    }

    mqtt_await_rel_timeout {
        desc {
            en: """The QoS 2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout."""
            zh: """PUBREL (Client -> Broker) 最大等待时间，超时则会被丢弃。"""
        }
        label: {
            en: """Max Awaiting PUBREL TIMEOUT"""
            zh: """Max Awaiting PUBREL TIMEOUT"""
        }
    }

    mqtt_session_expiry_interval {
        desc {
            en: """Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections."""
            zh: """指定会话将在连接断开后多久过期，仅适用于非 MQTT 5.0 的连接。"""
        }
        label: {
            en: """Session Expiry Interval"""
            zh: """会话过期间隔"""
        }
    }

    mqtt_max_mqueue_len {
        desc {
            en: """Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full."""
            zh: """消息队列最大长度。持久客户端断开连接或飞行窗口已满时排队的消息长度。"""
        }
        label: {
            en: """Max Message Queue Length"""
            zh: """最大消息队列长度"""
        }
    }

    mqtt_mqueue_priorities {
        desc {
            en: """Topic priorities. Priority number [1-255]
There's no priority table by default, hence all messages are treated equal.

**NOTE**: Comma and equal signs are not allowed for priority topic names.
**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.

**Examples**:
To configure <code>\"topic/1\" > \"topic/2\"</code>:
<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>
"""
            zh: """主题优先级。取值范围 [1-255]
默认优先级表为空，即所有的主题优先级相同。

注：优先主题名称中不支持使用逗号和等号。
注：不在此列表中的主题，被视为最高/最低优先级，这取决于<code>mqtt.mqueue_default_priority</code> 的配置

示例：
配置 <code>\"topic/1\" > \"topic/2\"</code>:
<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>
"""
        }
        label: {
            en: """Topic Priorities"""
            zh: """主题优先级"""
        }
    }

    mqtt_mqueue_default_priority {
        desc {
            en: """Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>)."""
            zh: """默认的主题优先级，不在 <code>主题优先级</code>（<code>mqueue_priorities</code>） 中的主题将会使用该优先级。"""
        }
        label: {
            en: """Default Topic Priorities"""
            zh: """默认主题优先级"""
        }
    }

    mqtt_mqueue_store_qos0 {
        desc {
            en: """Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains."""
            zh: """指定在连接断开但会话保持期间，是否需要在消息队列中存储 QoS 0 消息。"""
        }
        label: {
            en: """Store QoS 0 Message"""
            zh: """存储 QoS 0 消息"""
        }
    }

    mqtt_use_username_as_clientid {
        desc {
            en: """Whether to user Client ID as Username.
This setting takes effect later than <code>Use Peer Certificate as Username</code> (<code>peer_cert_as_username</code>) and <code>Use peer certificate as Client ID</code> (<code>peer_cert_as_clientid</code>).
"""
            zh: """是否使用用户名作为客户端 ID。
此设置的作用时间晚于 <code>使用对端证书作为用户名</code>（<code>peer_cert_as_username</code>） 和 <code>使用对端证书作为客户端 ID</code>（<code>peer_cert_as_clientid</code>）。
"""
        }
        label: {
            en: """Use Username as Client ID"""
            zh: """使用用户名作为客户端 ID"""
        }
    }

    mqtt_peer_cert_as_username {
        desc {
            en: """Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.
Supported configurations are the following:
- <code>cn</code>: Take the CN field of the certificate as Username
- <code>dn</code>: Take the DN field of the certificate as Username
- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Username
- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Username
- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Username
"""
            zh: """使用对端证书中的 CN, DN 字段或整个证书内容来作为用户名。仅适用于 TLS 连接。
目前支持配置为以下内容：
- <code>cn</code>: 取证书的 CN 字段作为 Username
- <code>dn</code>: 取证书的 DN 字段作为 Username
- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容作为 Username
- <code>pem</code>: 将 <code>DER</code> 证书内容转换为 <code>PEM</code> 格式后作为 Username
- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容的 MD5 值作为 Username
"""
        }
        label: {
            en: """Use Peer Certificate as Username"""
            zh: """使用对端证书作为用户名"""
        }
    }

    mqtt_peer_cert_as_clientid {
        desc {
            en: """Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.
Supported configurations are the following:
- <code>cn</code>: Take the CN field of the certificate as Client ID
- <code>dn</code>: Take the DN field of the certificate as Client ID
- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID
- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Client ID
- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID
"""
            zh: """使用对端证书中的 CN, DN 字段或整个证书内容来作为客户端 ID。仅适用于 TLS 连接。
目前支持配置为以下内容：
- <code>cn</code>: 取证书的 CN 字段作为 Client ID
- <code>dn</code>: 取证书的 DN 字段作为 Client ID
- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容作为 Client ID
- <code>pem</code>: 将 <code>DER</code> 证书内容转换为 <code>PEM</code> 格式后作为 Client ID
- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容的 MD5 值作为 Client ID
"""
        }
        label: {
            en: """Use Peer Certificate as Client ID"""
            zh: """使用对端证书作为客户端 ID"""
        }
    }

    broker {
        desc {
            en: """Message broker options."""
            zh: """Broker 相关配置项。"""
        }
    }

    broker_enable_session_registry {
        desc {
            en: """Enable session registry"""
            zh: """是否启用 Session Registry"""
        }
    }

    broker_session_locking_strategy {
        desc {
            en: """Session locking strategy in a cluster.
  - `local`: only lock the session on the current node
  - `one`: select only one remote node to lock the session
  - `quorum`: select some nodes to lock the session
  - `all`: lock the session on all the nodes in the cluster
"""

            zh: """Session 在集群中的锁策略。
  - `loca`: 仅锁本节点的 Session
  - `one`: 任选一个其它节点加锁
  - `quorum`: 选择集群中半数以上的节点加锁
  - `all`: 选择所有节点加锁
"""
        }
    }

    broker_shared_subscription_strategy {
        desc {
            en: """Dispatch strategy for shared subscription.
  - `random`: dispatch the message to a random selected subscriber
  - `round_robin`: select the subscribers in a round-robin manner
  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.
  - `hash`: select the subscribers by the hash of `clientIds`
"""

            zh: """共享订阅消息派发策略。
  - `random`: 随机挑选一个共享订阅者派发
  - `round_robin`: 使用 round-robin 策略派发
  - `sticky`: 总是使用上次选中的订阅者派发，直到它断开连接
  - `hash`: 使用发送者的 Client ID 进行 Hash 来选择订阅者
"""
        }
    }

    broker_shared_dispatch_ack_enabled {
        desc {
            en: """Enable/disable shared dispatch acknowledgement for QoS 1 and QoS 2 messages.
This should allow messages to be dispatched to a different subscriber in the group in case the picked (based on `shared_subscription_strategy`) subscriber is offline.
"""

            zh: """启用/禁用 QoS 1 和 QoS 2 消息的共享派发确认。
开启后，允许将消息从未及时回复 ACK 的订阅者 （例如，客户端离线）重新派发给另外一个订阅者。
"""
        }
    }

    broker_route_batch_clean {
        desc {
            en: """Enable batch clean for deleted routes."""
            zh: """是否开启批量清除路由。"""
        }
    }

    shared_subscription_group_strategy {
        desc {
            en: """Per group dispatch strategy for shared subscription.
This config is a map from shared subscription group name to the strategy
name. The group name should be of format `[A-Za-z0-9]`. i.e. no
special characters are allowed.
"""
            cn: """设置共享订阅组为单位的分发策略。该配置是一个从组名到
策略名的一个map，组名不得包含 `[A-Za-z0-9]` 之外的特殊字符。
"""
          }

    }

    shared_subscription_strategy_enum {
        desc {
            en: """Dispatch strategy for shared subscription.
- `random`: dispatch the message to a random selected subscriber
- `round_robin`: select the subscribers in a round-robin manner
- `sticky`: always use the last selected subscriber to dispatch,
until the subscriber disconnects.
- `hash`: select the subscribers by the hash of `clientIds`
- `local`: send to a random local subscriber. If local
subscriber was not found, send to a random subscriber cluster-wide
"""
            cn: """共享订阅的分发策略名称。
- `random`: 随机选择一个组内成员；
- `round_robin`: 循环选择下一个成员；
- `sticky`: 使用上一次选中的成员；
- `hash`: 根据 ClientID 哈希映射到一个成员；
- `local`: 随机分发到节点本地成成员，如果本地成员不存在，则随机分发
到任意一个成员。
"""

          }
      }

    broker_perf_route_lock_type {
        desc {
            en: """Performance tuning for subscribing/unsubscribing a wildcard topic.
Change this parameter only when there are many wildcard topics.

NOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.
  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.
  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.
  - `global`: updates are protected with a global lock. Recommended for large clusters.
"""
            zh: """通配主题订阅/取消订阅性能调优。
建议仅当通配符主题较多时才更改此参数。

注：当从/更改为 `global` 锁时，它要求集群中的所有节点在更改之前停止。
  - `key`: 为 Mnesia 事务涉及到的每个 key 上锁，建议单节点时使用。
  - `tab`: 为 Mnesia 事务涉及到的表上锁，建议在集群中使用。
  - `global`: 所以更新操作都被全局的锁保护，仅建议在超大规模集群中使用。
"""
        }
    }

    broker_perf_trie_compaction {
        desc {
            en: """Enable trie path compaction.
Enabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.
Topic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.

NOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it.
"""
            zh: """是否开启主题表压缩存储。
启用它会显着提高通配符主题订阅率，如果通配符主题具有唯一前缀，例如：'sensor/{{id}}/+/'，其中每个订阅者的 ID 是唯一的。
如果消息主要发布到具有大量级别的主题，则主题匹配性能（发布时）可能会降低。

注意：这是一个集群范围的配置。 它要求在更改之前停止所有节点。
"""
        }
    }

    sys_topics {
        desc {
            en: """System topics configuration."""
            zh: """系统主题配置。"""
        }
    }

    sys_msg_interval {
        desc {
            en: """Time interval of publishing `$SYS` messages."""
            zh: """发送 `$SYS` 主题的间隔时间。"""
        }
    }

    sys_heartbeat_interval {
        desc {
            en: """Time interval for publishing following heartbeat messages:
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`
"""
            zh: """发送心跳系统消息的间隔时间，它包括：
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`
"""
        }
    }

    sys_event_messages {
        desc {
            en: """Client events messages"""
            zh: """客户端事件消息"""
        }
    }

    sys_event_client_connected {
        desc {
            en: """Enable to publish client connected event messages"""
            zh: """是否开启客户端已连接事件消息。"""
        }
    }

    sys_event_client_disconnected {
        desc {
            en: """Enable to publish client disconnected event messages."""
            zh: """是否开启客户端已断开连接事件消息。"""
        }
    }

    sys_event_client_subscribed {
        desc {
            en: """Enable to publish event message that client subscribed a topic successfully."""
            zh: """是否开启客户端已成功订阅主题事件消息。"""
        }
    }

    sys_event_client_unsubscribed {
        desc {
            en: """Enable to publish event message that client unsubscribed a topic successfully."""
            zh: """是否开启客户端已成功取消订阅主题事件消息。"""
        }
    }


fields_authorization_no_match {
    desc {
        en: """
Default access control action if the user or client matches no ACL rules,
or if no such user or client is found by the configurable authorization
sources such as built_in_database, an HTTP API, or a query against PostgreSQL.
Find more details in 'authorization.sources' config.
"""
        zh: """
如果用户或客户端不匹配ACL规则，或者从可配置授权源(比如内置数据库、HTTP API 或 PostgreSQL 等。)内未找
到此类用户或客户端时，模式的认访问控制操作。
在“授权”中查找更多详细信息。
"""
    }
    label: {
        en: "Authorization no match"
        zh: "未匹时的默认授权动作"
    }
}

fields_authorization_deny_action {
    desc {
        en: """
The action when the authorization check rejects an operation.
"""
        zh: """
授权检查拒绝操作时的操作。
"""
    }
    label: {
        en: "Authorization deny action"
        zh: "授权检查拒绝操作时的操作"
    }
}

fields_cache_enable {
    desc {
        en: """
Enable or disable the authorization cache.
"""
        zh: """
启用或禁用授权缓存。
"""
    }
    label: {
        en: "Enable or disable the authorization cache."
        zh: "启用或禁用授权缓存"
    }
}

fields_cache_max_size {
    desc {
        en: """
Maximum number of cached items.
"""
        zh: """
缓存项的最大数量。
"""
    }
    label: {
        en: "Maximum number of cached items."
        zh: "缓存项的最大数量"
    }
}

fields_cache_ttl {
    desc {
        en: """
Time to live for the cached data.
"""
        zh: """
缓存数据的生存时间。
"""
    }
    label: {
        en: "Time to live for the cached data."
        zh: "缓存数据的生存时间。"
    }
}

fields_deflate_opts_level {
    desc {
        en: """
Compression level.
"""
        zh: """压缩级别"""
    }
    label: {
        en: "Compression level"
        zh: "压缩级别"
    }
}

fields_deflate_opts_mem_level {
    desc {
        en: """
Specifies the size of the compression state.</br>
Lower values decrease memory usage per connection.
"""
        zh: """
指定压缩状态的大小</br>
较低的值会减少每个连接的内存使用。
"""
    }
    label: {
        en: "Size of the compression state"
        zh: "压缩状态大小"
    }
}

fields_deflate_opts_strategy {
    desc {
        en: """
Specifies the compression strategy.
"""
        zh: """
指定压缩策略。
"""
    }
    label: {
        en: "compression strategy"
        zh: "指定压缩策略"
    }
}

fields_deflate_opts_server_context_takeover {
    desc {
        en: """
Takeover means the compression state is retained between server messages.
"""
        zh: """接管意味着在服务器消息之间保留压缩状态。"""
    }
    label: {
        en: "Server context takeover"
        zh: "服务上下文接管"
    }
}

fields_deflate_opts_client_context_takeover {
    desc {
        en: """
Takeover means the compression state is retained between client messages.
"""
        zh: """
接管意味着在客户端消息之间保留压缩状态。
"""
    }
    label: {
        en: "Client context takeover"
        zh: "客户端上下文接管"
    }
}

fields_deflate_opts_server_max_window_bits {
    desc {
        en: """
Specifies the size of the compression context for the server.
"""
        zh: """
指定服务器压缩上下文的大小。
"""
    }
    label: {
        en: "Server compression max window size"
        zh: "服务器压缩窗口大小"
    }
}

fields_deflate_opts_client_max_window_bits {
    desc {
        en: """
Specifies the size of the compression context for the client.
"""
        zh: """
指定客户端压缩上下文的大小。
"""
    }
    label: {
        en: "Client compression max window size"
        zh: "压缩窗口大小"
    }
}

client_ssl_opts_schema_enable {
    desc {
        en: """
Enable TLS.
"""
        zh: """启用 TLS"""
    }
    label: {
        en: "Enable TLS."
        zh: "启用 TLS"
    }
}

common_ssl_opts_schema_cacertfile {
    desc {
        en: """
Trusted PEM format CA certificates bundle file.</br>
The certificates in this file are used to verify the TLS peer's certificates.
Append new certificates to the file if new CAs are to be trusted.
There is no need to restart EMQX to have the updated file loaded, because
the system regularly checks if file has been updated (and reload).</br>
NOTE: invalidating (deleting) a certificate from the file will not affect
already established connections.
"""
        zh: """
受信任的PEM格式CA证书捆绑文件</br>
此文件中的证书用于验证TLS对等方的证书。
如果要信任新CA，请将新证书附加到文件中。
无需重启EMQX即可加载更新的文件，因为系统会定期检查文件是否已更新（并重新加载）</br>
注意：从文件中失效（删除）证书不会影响已建立的连接。
"""
    }
    label: {
        en: "CACertfile"
        zh: "CA 证书文件"
    }
}

common_ssl_opts_schema_certfile {
    desc {
        en: """
PEM format certificates chain file.</br>
The certificates in this file should be in reversed order of the certificate
issue chain. That is, the host's certificate should be placed in the beginning
of the file, followed by the immediate issuer certificate and so on.
Although the root CA certificate is optional, it should be placed at the end of
the file if it is to be added.
"""
        zh: """
PEM格式证书链文件</br>
此文件中的证书应与证书颁发链的顺序相反。也就是说，主机的证书应该放在文件的开头，然后是直接颁发者证书，依此类推。
虽然根CA证书是可选的，但它应该放在
如果要添加文件，请将其删除。
"""
    }
    label: {
        en: "Certfile"
        zh: "证书文件"
    }
}

common_ssl_opts_schema_keyfile {
    desc {
        en: """
PEM format private key file.
"""
        zh: """
PEM格式的私钥文件。
"""
    }
    label: {
        en: "Keyfile"
        zh: "私钥文件"
    }
}

common_ssl_opts_schema_verify {
    desc {
        en: """
Enable or disable peer verification.
"""
        zh: """
启用或禁用对等验证。
"""
    }
    label: {
        en: "Verify peer"
        zh: "对等验证"
    }
}

common_ssl_opts_schema_reuse_sessions {
    desc {
        en: """
Enable TLS session reuse.
"""
        zh: """
启用 TLS 会话重用。
"""
    }
    label: {
        en: "TLS session reuse"
        zh: "TLS 会话重用"
    }
}

common_ssl_opts_schema_depth {
    desc {
        en: """
Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.
"""
        zh: """
在有效的证书路径中，可以跟随对等证书的非自颁发中间证书的最大数量。因此，如果深度为0，则对等方必须由受信任的根CA直接签名；如果1，路径可以是PEER、CA、ROOT-CA；如果是2，则路径可以是PEER、CA、CA、ROOT-CA等等。默认值为10。
"""
    }
    label: {
        en: "CACert Depth"
        zh: "CA 证书深度"
    }
}

common_ssl_opts_schema_password {
    desc {
        en: """
String containing the user's password.
Only used if the private key file is password-protected.
"""
        zh: """
包含用户密码的字符串。
仅在私钥文件受密码保护时使用。
"""
    }
    label: {
        en: "Keyfile passphrase"
        zh: "秘钥文件密码"
    }
}

common_ssl_opts_schema_versions {
    desc {
        en: """
All TLS/DTLS versions to be supported.</br>
NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>
In case PSK cipher suites are intended, make sure to configured
<code>['tlsv1.2', 'tlsv1.1']</code> here.
"""
        zh: """
支持所有TLS/DTLS版本</br>

注：PSK 的 Ciphers 无法在 <code>tlsv1.3</code> 中使用，如果打算使用 PSK 密码套件，请确保这里配置为 <code>["tlsv1.2","tlsv1.1"]</code>。
"""
    }
    label: {
        en: "SSL versions"
        zh: "SSL 版本"
    }
}

ciphers_schema_common {
    desc {
        en: """
This config holds TLS cipher suite names separated by comma,
or as an array of strings. e.g.
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
</br>
Ciphers (and their ordering) define the way in which the
client and server encrypts information over the network connection.
Selecting a good cipher suite is critical for the
application's data security, confidentiality and performance.

The names should be in OpenSSL string format (not RFC format).
All default values and examples provided by EMQX config
documentation are all in OpenSSL format.</br>

NOTE: Certain cipher suites are only compatible with
specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
incompatible cipher suites will be silently dropped.
For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
configuring cipher suites for other versions will have no effect.
</br>

NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
"""
        zh: """
此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code>或
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>。
</br>
密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。
选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。

名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。
EMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式</br>
注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。
不兼容的密码套件将被自动删除。

例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。

</br>
注：PSK 的 Ciphers 不支持 tlsv1.3</br>
如果打算使用PSK密码套件 <code>tlsv1.3</code>。应在<code>ssl.versions</code>中禁用。

</br>
PSK 密码套件：
<code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
"""
    }
    label: {
        en: ""
        zh: ""
    }
}

ciphers_schema_quic {
    desc {
        en: """
This config holds TLS cipher suite names separated by comma,
or as an array of strings. e.g.
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
</br>
Ciphers (and their ordering) define the way in which the
client and server encrypts information over the network connection.
Selecting a good cipher suite is critical for the
application's data security, confidentiality and performance.

The names should be in OpenSSL string format (not RFC format).
All default values and examples provided by EMQX config
documentation are all in OpenSSL format.</br>

NOTE: Certain cipher suites are only compatible with
specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
incompatible cipher suites will be silently dropped.
For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
configuring cipher suites for other versions will have no effect.
</br>

NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>

NOTE: QUIC listener supports only 'tlsv1.3' ciphers</br>
"""
        zh: """
此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code>或
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>。
</br>
密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。
选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。

名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。
EMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式</br>
注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。
不兼容的密码套件将被自动删除。

例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。

</br>
注：PSK 的 Ciphers 不支持 tlsv1.3</br>
如果打算使用PSK密码套件，<code>tlsv1.3</code>。应在<code>ssl.versions</code>中禁用。

</br>
PSK 密码套件：
<code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>

注：QUIC 监听器不支持 tlsv1.3 的 ciphers
"""
    }
    label: {
        en: ""
        zh: ""
    }
}

common_ssl_opts_schema_user_lookup_fun {
    desc {
        en: """
EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.
"""
        zh: """
用于查找预共享密钥（PSK）标识的 EMQX 内部回调。
"""
    }
    label: {
        en: "SSL PSK user lookup fun"
        zh: "SSL PSK 用户回调"
    }
}

common_ssl_opts_schema_secure_renegotiate {
    desc {
        en: """
SSL parameter renegotiation is a feature that allows a client and a server
to renegotiate the parameters of the SSL connection on the fly.
RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
you drop support for the insecure renegotiation, prone to MitM attacks.
"""
        zh: """
SSL 参数重新协商是一种允许客户端和服务器动态重新协商 SSL 连接参数的功能。
RFC 5746 定义了一种更安全的方法。通过启用安全的重新协商，您就失去了对不安全的重新协商的支持，从而容易受到 MitM 攻击。
"""
    }
    label: {
        en: "SSL renegotiate"
        zh: "SSL 重新协商"
    }
}

server_ssl_opts_schema_dhfile {
    desc {
        en: """
Path to a file containing PEM-encoded Diffie-Hellman parameters
to be used by the server if a cipher suite using Diffie-Hellman
key exchange is negotiated. If not specified, default parameters
are used.</br>
NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.
"""
        zh: """
如果协商使用Diffie-Hellman密钥交换的密码套件，则服务器将使用包含PEM编码的Diffie-Hellman参数的文件的路径。如果未指定，则使用默认参数</br>

注意：TLS 1.3不支持<code>dhfile</code>选项。
"""
    }
    label: {
        en: "SSL dhfile"
        zh: "SSL dhfile"
    }
}

server_ssl_opts_schema_fail_if_no_peer_cert {
    desc {
        en: """
Used together with {verify, verify_peer} by an TLS/DTLS server.
If set to true, the server fails if the client does not have a
certificate to send, that is, sends an empty certificate.
If set to false, it fails only if the client sends an invalid
certificate (an empty certificate is considered valid).
"""
        zh: """
TLS/DTLS 服务器与 {verify，verify_peer} 一起使用。
如果设置为true，则如果客户端没有要发送的证书，即发送空证书，服务器将失败。
如果设置为false，则仅当客户端发送无效证书（空证书被视为有效证书）时才会失败。
"""
    }
    label: {
        en: "SSL fail if no peer cert"
        zh: "没有证书则 SSL 失败"
    }
}

server_ssl_opts_schema_honor_cipher_order {
    desc {
        en: """
An important security setting, it forces the cipher to be set based
 on the server-specified order instead of the client-specified order,
 hence enforcing the (usually more properly configured) security
 ordering of the server administrator.
"""
        zh: """
一个重要的安全设置，它强制根据服务器指定的顺序而不是客户机指定的顺序设置密码，从而强制服务器管理员执行（通常配置得更正确）安全顺序。
"""
    }
    label: {
        en: "SSL honor cipher order"
        zh: "SSL honor cipher order"
    }
}

server_ssl_opts_schema_client_renegotiation {
    desc {
        en: """
In protocols that support client-initiated renegotiation,
the cost of resources of such an operation is higher for the server than the client.
This can act as a vector for denial of service attacks.
The SSL application already takes measures to counter-act such attempts,
but client-initiated renegotiation can be strictly disabled by setting this option to false.
The default value is true. Note that disabling renegotiation can result in
long-lived connections becoming unusable due to limits on
the number of messages the underlying cipher suite can encipher.
"""
        zh: """
在支持客户机发起的重新协商的协议中，这种操作的资源成本对于服务器来说高于客户机。
这可能会成为拒绝服务攻击的载体。
SSL 应用程序已经采取措施来反击此类尝试，但通过将此选项设置为 false，可以严格禁用客户端发起的重新协商。
默认值为 true。请注意，由于基础密码套件可以加密的消息数量有限，禁用重新协商可能会导致长期连接变得不可用。
"""
    }
    label: {
        en: "SSL client renegotiation"
        zh: "SSL 客户端冲协商"
    }
}

server_ssl_opts_schema_handshake_timeout {
    desc {
        en: """
Maximum time duration allowed for the handshake to complete
"""
        zh: """
握手完成所允许的最长时间
"""
    }
    label: {
        en: "Handshake timeout"
        zh: "握手超时时间"
    }
}

fields_listeners_tcp {
    desc {
        en: """
TCP listeners
"""
        zh: """TCP 监听器"""
    }
    label: {
        en: "TCP listeners"
        zh: "TCP 监听器"
    }
}

fields_listeners_ssl {
    desc {
        en: """
SSL listeners
"""
        zh: """SSL 监听器"""
    }
    label: {
        en: "SSL listeners"
        zh: "SSL 监听器"
    }
}

fields_listeners_ws {
    desc {
        en: """
HTTP websocket listeners
"""
        zh: """HTTP websocket 监听器"""
    }
    label: {
        en: "HTTP websocket listeners"
        zh: "HTTP websocket 监听器"
    }
}

fields_listeners_wss {
    desc {
        en: """
HTTPS websocket listeners
"""
        zh: """HTTPS websocket 监听器"""
    }
    label: {
        en: "HTTPS websocket listeners"
        zh: "HTTPS websocket 监听器"
    }
}

fields_listeners_quic {
    desc {
        en: """
QUIC listeners
"""
        zh: """QUIC 监听器"""
    }
    label: {
        en: "QUIC listeners"
        zh: "QUIC 监听器"
    }
}

fields_listener_enabled {
    desc {
        en: """
Enable listener.
"""
        zh: """启停监听器"""
    }
    label: {
        en: "Enable listener"
        zh: "启停监听器"
    }
}

fields_mqtt_quic_listener_certfile {
    desc {
        en: """
Path to the certificate file.
"""
        zh: """证书文件"""
    }
    label: {
        en: "Certificate file"
        zh: "证书文件"
    }
}

fields_mqtt_quic_listener_keyfile {
    desc {
        en: """
Path to the secret key file.
"""
        zh: """私钥文件"""
    }
    label: {
        en: "Key file"
        zh: "私钥文件"
    }
}

fields_mqtt_quic_listener_idle_timeout {
    desc {
        en: """
Close transport-layer connections from the clients that have not sent MQTT CONNECT
message within this interval.
"""
        zh: """
关闭在此间隔内未发送 MQTT CONNECT 消息的客户端的传输层连接。
"""
    }
    label: {
        en: "Idle Timeout"
        zh: "发呆超时时间"
    }
}

base_listener_bind {
    desc {
        en: """
IP address and port for the listening socket.
"""
        zh: """
监听套接字的 IP 地址和端口。
"""
    }
    label: {
        en: "IP address and port"
        zh: "IP 地址和端口"
    }
}

base_listener_acceptors {
    desc {
        en: """
The size of the listener's receiving pool.
"""
        zh: """监听器接收池的大小。"""
    }
    label: {
        en: "Acceptors Num"
        zh: "接收器数量"
    }
}

base_listener_max_connections {
    desc {
        en: """
The maximum number of concurrent connections allowed by the listener.
"""
        zh: """
监听器允许的最大并发连接数。
"""
    }
    label: {
        en: "Max connections"
        zh: "最大并发连接数"
    }
}

base_listener_mountpoint {
    desc {
        en: """
When publishing or subscribing, prefix all topics with a mountpoint string.
The prefixed string will be removed from the topic name when the message
is delivered to the subscriber. The mountpoint is a way that users can use
to implement isolation of message routing between different listeners.
For example if a client A subscribes to `t` with `listeners.tcp.\<name>.mountpoint`
set to `some_tenant`, then the client actually subscribes to the topic
`some_tenant/t`. Similarly, if another client B (connected to the same listener
as the client A) sends a message to topic `t`, the message is routed
to all the clients subscribed `some_tenant/t`, so client A will receive the
message, with topic name `t`.</br>
Set to `""` to disable the feature.</br>

Variables in mountpoint string:
  - <code>${clientid}</code>: clientid
  - <code>${username}</code>: username
"""
        zh: """
发布或订阅时，请在所有主题前面加上 mountpoint 字符串。

将消息传递给订阅者时，将从主题名称中删除带前缀的字符串。挂载点是一种用户可以用来实现不同侦听器之间消息路由隔离的方法。

例如，如果客户机 A 使用 <code>listeners.tcp.\<name>.mountpoint</code> 设置为'some_tenant'，那么客户端实际上订阅了主题'some_tenant/t'。</br>
类似地，如果另一个客户端B（与客户端A连接到同一个侦听器）向主题 't' 发送消息，该消息将路由到所有订阅了'some_租户/t'的客户端，因此客户端 A 将接收主题名为't'的消息</br>

设置为<code>""</code> 以禁用该功能</br>

mountpoint 字符串中的变量：
- <code>${clientid}</code>: clientid
- <code>${username}</code>: username
"""
    }
    label: {
        en: "mountpoint"
        zh: "mountpoint"
    }
}

base_listener_zone {
    desc {
        en: """
The configuration zone to which the listener belongs.
"""
        zh: """
监听器所属的配置组。
"""
    }
    label: {
        en: "Zone"
        zh: "配置组"
    }
}

base_listener_limiter {
    desc {
        en: """
Type of the rate limit.
"""
        zh: """
速率限制类型
"""
    }
    label: {
        en: "Type of the rate limit."
        zh: "速率限制类型"
    }
}

base_listener_enable_authn {
    desc {
        en: """
Set <code>true</code> (default) to enable client authentication on this listener.
When set to <code>false</code> clients will be allowed to connect without authentication.
"""
        zh: """
配置 <code>true</code> （默认值）启用客户端进行身份认证。
配置 <code>false</code> 时，将不对客户端做任何认证。
"""
    }
    label: {
        en: "Enable authentication"
        zh: "启用身份认证"
    }
}

mqtt_listener_access_rules {
    desc {
        en: """
The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny
"""
        zh: """此监听器的访问控制规则。"""
    }
    label: {
        en: "Access rules"
        zh: "访问控制规则"
    }
}

mqtt_listener_proxy_protocol {
    desc {
        en: """
Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>
See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
"""
        zh: """
如果EMQX集群部署在 HAProxy 或 Nginx 之后，请启用代理协议 V1/2 </br>
详情见: https://www.haproxy.com/blog/haproxy/proxy-protocol/
"""
    }
    label: {
        en: "Proxy protocol"
        zh: "Proxy protocol"
    }
}

mqtt_listener_proxy_protocol_timeout {
    desc {
        en: """
Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.
"""
        zh: """
代理协议超时。如果在超时时间内未收到代理协议数据包，EMQX将关闭TCP连接。
"""
    }
    label: {
        en: "Proxy protocol timeout"
        zh: "Proxy protocol 超时时间"
    }
}

global_authentication {
    desc {
        en: """Default authentication configs for all MQTT listeners.

For per-listener overrides see <code>authentication</code> in listener configs

This option can be configured with:
<ul>
  <li><code>[]</code>: The default value, it allows *ALL* logins</li>
  <li>one: For example <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>
  <li>chain: An array of structs.</li>
</ul>

When a chain is configured, the login credentials are checked against the backends per the configured order, until an 'allow' or 'deny' decision can be made.

If there is no decision after a full chain exhaustion, the login is rejected.
"""
        zh: """全局 MQTT 监听器的默认认证配置。 为每个监听器配置认证参考监听器器配置中的<code>authentication</code> 配置。

该配置可以被配置为：
<ul>
  <li><code>[]</code>: 默认值，允许所以登录请求
  <li>配置为单认证器，例如 <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>
  <li>配置为认证器数组</li>
</ul>

当配置为认证链后，登录凭证会按照配置的顺序进行检查，直到做出<code>allow</code> 或 <code>deny</code>的结果。

如果在所有的认证器都执行完后，还是没有结果，登录将被拒绝。
"""
    }
}

listener_authentication {
    desc {
        en: """
Per-listener authentication override.
Authentication can be one single authenticator instance or a chain of authenticators as an array.
When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br>

"""
        zh: """
监听器认证重载。

认证配置可以是单个认证器实例，也可以是一个认证器数组组成的认证链。
执行登录验证时（用户名、客户端 ID 等），将按配置的顺序执行</br>
"""
    }
    label: {
        en: "Per-listener authentication override"
        zh: "每个监听器的认证覆盖"
    }
}

fields_rate_limit_max_conn_rate {
    desc {
        en: """
Maximum connections per second.
"""
        zh: """
每秒最大连接数。
"""
    }
    label: {
        en: "Max connection rate"
        zh: "每秒最大连接数"
    }
}

fields_rate_limit_conn_messages_in {
    desc {
        en: """
Message limit for the external MQTT connections.
"""
        zh: """
外部 MQTT 连接的消息限制。
"""
    }
    label: {
        en: "connecting messages in"
        zh: "外部 MQTT 连接的消息限制"
    }
}

fields_rate_limit_conn_bytes_in {
    desc {
        en: """
Limit the rate of receiving packets for a MQTT connection.
The rate is counted by bytes of packets per second.
"""
        zh: """
限制 MQTT 连接接收数据包的速率。
速率以每秒的数据包字节数计算。
"""
    }
    label: {
        en: "Connection bytes in"
        zh: "数据包速率"
    }
}

client_ssl_opts_schema_server_name_indication {
    desc {
        en: """
Specify the host name to be used in TLS Server Name Indication extension.</br>
For instance, when connecting to "server.example.net", the genuine server
which accepts the connection and performs TLS handshake may differ from the
host the TLS client initially connects to, e.g. when connecting to an IP address
or when the host has multiple resolvable DNS records </br>
If not specified, it will default to the host name string which is used
to establish the connection, unless it is IP addressed used.</br>
The host name is then also used in the host name verification of the peer
certificate.</br> The special value 'disable' prevents the Server Name
Indication extension from being sent and disables the hostname
verification check.
"""
        zh: """
指定要在 TLS 服务器名称指示扩展中使用的主机名</br>
例如，当连接到 "server.example.net" 时，接受连接并执行 TLS 握手的真正服务器可能与 TLS 客户端最初连接到的主机不同，
例如，当连接到 IP 地址时，或者当主机具有多个可解析的 DNS 记录时</br>
如果未指定，它将默认为使用的主机名字符串
建立连接，除非使用 IP 地址</br>
然后，主机名也用于对等机的主机名验证
证书</br>特殊值'disable'阻止发送服务器名称指示扩展，并禁用主机名验证检查。
"""
    }
    label: {
        en: "Server Name Indication"
        zh: "服务器名称指示"
    }
}

fields_tcp_opts_active_n {
    desc {
        en: """
Specify the {active, N} option for this Socket.</br>
See: https://erlang.org/doc/man/inet.html#setopts-2
"""
        zh: """
为此套接字指定{active，N}选项</br>
See: https://erlang.org/doc/man/inet.html#setopts-2
"""
    }
    label: {
        en: "active_n"
        zh: "active_n"
    }
}

fields_tcp_opts_backlog {
    desc {
        en: """
TCP backlog defines the maximum length that the queue of
 pending connections can grow to.
"""
        zh: """
TCP backlog 定义了挂起连接队列可以增长到的最大长度。
"""
    }
    label: {
        en: "TCP backlog length"
        zh: "TCP 连接队列长度"
    }
}

fields_tcp_opts_send_timeout {
    desc {
        en: """
The TCP send timeout for the connections.
"""
        zh: """
连接的TCP发送超时。
"""
    }
    label: {
        en: "TCP send timeout"
        zh: "TCP 发送超时"
    }
}

fields_tcp_opts_send_timeout_close {
    desc {
        en: """
Close the connection if send timeout.
"""
        zh: """
如果发送超时，则关闭连接。
"""
    }
    label: {
        en: "TCP send timeout close"
        zh: "TCP 发送超时关闭连接"
    }
}

fields_tcp_opts_recbuf {
    desc {
        en: """
The TCP receive buffer (OS kernel) for the connections.
"""
        zh: """
连接的 TCP 接收缓冲区（OS内核）。
"""
    }
    label: {
        en: "TCP receive buffer"
        zh: "TCP 接收缓冲区"
    }
}

fields_tcp_opts_sndbuf {
    desc {
        en: """
The TCP send buffer (OS kernel) for the connections.
"""
        zh: """
连接的 TCP 发送缓冲区（OS内核）。
"""
    }
    label: {
        en: "TCP send buffer"
        zh: "TCP 发送缓冲区"
    }
}

fields_tcp_opts_buffer {
    desc {
        en: """
The size of the user-space buffer used by the driver.
"""
        zh: """
驱动程序使用的用户空间缓冲区的大小。
"""
    }
    label: {
        en: "TCP user-space buffer"
        zh: "TCP 用户态缓冲区"
    }
}

fields_tcp_opts_high_watermark {
    desc {
        en: """
The socket is set to a busy state when the amount of data queued internally
  by the VM socket implementation reaches this limit.
"""
        zh: """
当 VM 套接字实现内部排队的数据量达到此限制时，套接字将设置为忙碌状态。
"""
    }
    label: {
        en: "TCP 高水位线"
        zh: ""
    }
}

fields_tcp_opts_nodelay {
    desc {
        en: """
The TCP_NODELAY flag for the connections.
"""
        zh: """
连接的 TCP_NODELAY 标识
"""
    }
    label: {
        en: "TCP_NODELAY"
        zh: "TCP_NODELAY"
    }
}

fields_tcp_opts_reuseaddr {
    desc {
        en: """
The SO_REUSEADDR flag for the connections.
"""
        zh: """
连接的 SO_REUSEADDR 标识
"""
    }
    label: {
        en: "SO_REUSEADDR"
        zh: "SO_REUSEADDR"
    }
}

fields_trace_payload_encode {
    desc {
        en: """
Determine the format of the payload format in the trace file.</br>
`text`: Text-based protocol or plain text protocol.
 It is recommended when payload is JSON encoded.</br>
`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.</br>
`hidden`: payload is obfuscated as `******`

"""
        zh: """
确定跟踪文件中有效负载格式的格式</br>
`text`：基于文本的协议或纯文本协议。
建议在有效负载为JSON编码时使用</br>
`hex`：二进制十六进制编码。当有效负载是自定义二进制协议时，建议使用此选项</br>
`hidden`：有效负载被模糊化为 `******`
"""
    }
    label: {
        en: "Payload encode"
        zh: "有效负载编码"
    }
}

fields_ws_opts_mqtt_path {
    desc {
        en: """
WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:
<code>ws://{ip}:{port}/mqtt</code>
"""
        zh: """
WebSocket 的 MQTT 协议路径。因此，EMQX Broker的WebSocket地址为：
<code>ws://{ip}:{port}/mqtt</code>
"""
    }
    label: {
        en: "WS MQTT Path"
        zh: "WS MQTT 路径"
    }
}

fields_ws_opts_mqtt_piggyback {
    desc {
        en: """
Whether a WebSocket message is allowed to contain multiple MQTT packets.
"""
        zh: """
WebSocket消息是否允许包含多个 MQTT 数据包。
"""
    }
    label: {
        en: "MQTT Piggyback"
        zh: "MQTT Piggyback"
    }
}

fields_ws_opts_compress {
    desc {
        en: """
If <code>true</code>, compress WebSocket messages using <code>zlib</code>.</br>
The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration.
"""
        zh: """
如果 <code>true</code>，则使用<code>zlib</code> 压缩 WebSocket 消息</br>
<code>deflate_opts</code> 下的配置项属于压缩相关参数配置。
"""
    }
    label: {
        en: "Ws compress"
        zh: "Ws 压缩"
    }
}

fields_ws_opts_idle_timeout {
    desc {
        en: """
Close transport-layer connections from the clients that have not sent MQTT CONNECT
message within this interval.
"""
        zh: """
关闭在此间隔内未发送 MQTT CONNECT 消息的客户端的传输层连接。
"""
    }
    label: {
        en: "WS idle timeout"
        zh: "WS 发呆时间"
    }
}

fields_ws_opts_max_frame_size {
    desc {
        en: """
The maximum length of a single MQTT packet.
"""
        zh: """
单个 MQTT 数据包的最大长度。
"""
    }
    label: {
        en: "Max frame size"
        zh: "最大数据包长度"
    }
}

fields_ws_opts_fail_if_no_subprotocol {
    desc {
        en: """
If <code>true</code>, the server will return an error when
 the client does not carry the <code>Sec-WebSocket-Protocol</code> field.
 </br>Note: WeChat applet needs to disable this verification.
"""
        zh: """
如果<code>true</code>，当客户端未携带<code>Sec WebSocket Protocol</code>字段时，服务器将返回一个错误。
</br>注意：微信小程序需要禁用此验证。
"""
    }
    label: {
        en: "Fail if no subprotocol"
        zh: "无 subprotocol 则失败"
    }
}

fields_ws_opts_supported_subprotocols {
    desc {
        en: """
Comma-separated list of supported subprotocols.
"""
        zh: """
逗号分隔的 subprotocols 支持列表。
"""
    }
    label: {
        en: "Supported subprotocols"
        zh: "Subprotocols 支持列表"
    }
}

fields_ws_opts_check_origin_enable {
    desc {
        en: """
If <code>true</code>, <code>origin</code> HTTP header will be
 validated against the list of allowed origins configured in <code>check_origins</code>
 parameter.
"""
        zh: """
如果<code>true</code>，<code>origin</code>HTTP 头将根据<code>check_origins</code>参数中配置的允许来源列表进行验证。
"""
    }
    label: {
        en: "Check origin"
        zh: "检查 origin"
    }
}

fields_ws_opts_allow_origin_absence {
    desc {
        en: """
If <code>false</code> and <code>check_origin_enable</code> is
 <code>true</code>, the server will reject requests that don't have <code>origin</code>
 HTTP header.
"""
        zh: """
If <code>false</code> and <code>check_origin_enable</code> is <code>true</code>, the server will reject requests that don't have <code>origin</code> HTTP header.
"""
    }
    label: {
        en: "Allow origin absence"
        zh: "允许 origin 缺失"
    }
}

fields_ws_opts_check_origins {
    desc {
        en: """
List of allowed origins.</br>See <code>check_origin_enable</code>.
"""
        zh: """
允许的 origins 列表
"""
    }
    label: {
        en: "Allowed origins"
        zh: "允许的 origins"
    }
}

fields_ws_opts_proxy_address_header {
    desc {
        en: """
HTTP header used to pass information about the client IP address.
Relevant when the EMQX cluster is deployed behind a load-balancer.
"""
        zh: """
HTTP 头，用于传递有关客户端 IP 地址的信息。
当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。
"""
    }
    label: {
        en: "Proxy address header"
        zh: "客户端地址头"
    }
}

fields_ws_opts_proxy_port_header {
    desc {
        en: """
HTTP header used to pass information about the client port.
Relevant when the EMQX cluster is deployed behind a load-balancer.
"""
        zh: """
HTTP 头，用于传递有关客户端端口的信息。
当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。
"""
    }
    label: {
        en: "Proxy port header"
        zh: "客户端端口头"
    }
}

}
